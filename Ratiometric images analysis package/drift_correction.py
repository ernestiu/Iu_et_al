# -*- coding: utf-8 -*-
"""
Created on Thu Apr 23 09:49:01 2020
https://pypi.org/project/pystackreg/
@author: ernes
"""

import numpy as np
import matplotlib.pyplot as plt
from skimage import io, exposure, img_as_float, img_as_ubyte, filters, feature
from pystackreg import StackReg
from pystackreg.util import to_uint16
from skimage.registration import phase_cross_correlation, optical_flow_tvl1
from scipy import ndimage as ndi
import os
# from image_corr_module import rolling_ball_background_subtract
from skimage.morphology import disk, white_tophat, reconstruction
from skimage.transform import warp
import tifffile


def drift_corr(ch1, tmat = None):
    '''
    This function takes a stack image and apply Stackreg drift correction.
    Parameters
    ------------
    ch1 : a 3-dimentional array
        
    Returns
    ------------
    new_ch1 : a 3-dimentional array
        The drift corrected ch1 image.
    
    tmats : the transformation matrix
    '''
    
    sr = StackReg(StackReg.TRANSLATION)
    # sr = StackReg(StackReg.RIGID_BODY)
    print ('Drift correction in progress...')        
       
    if tmat is None:
        tmats = sr.register_stack(ch1, reference='previous')
    else: # if there's a transformation provided
        tmats = tmat
        print('drift_corr: using the provided tmats to register images')
    ### how to use the tmat ###
    # import numpy as np
    # np.save('transformation_matrices.npy', tmats)
    
    # tmats_loaded = np.load('transformation_matrices.npy')
    
    # sr.transform_stack(img1, tmats=tmats_loaded)
    ### how to use the tmat ###
    
    new_ch1 = sr.transform_stack(ch1, tmats=tmats)
    # The output of the transform function therefore has a float datatype and may contain negative values. 
    # To again create an image with integer values, the utility function pystackreg.util.to_uint16() is used
    if ch1.dtype == 'uint16':
        new_ch1 = to_uint16(new_ch1)
    else:
        print('drift_corr: unknown image datatype')
    

    return new_ch1, tmats  
    
        
def multi_drift_corr(ref, ch1):
    '''
    This function takes a reference image and another image to be corrected and drift correct both stacks.
    Parameters
    ------------
    ref : a 3-dimentional array
        The reference image that will be used for drift correction.
    ch1 : a 3-dimentional array
        ch1 is drift corrected based on the shifts found in the stack ref.
        
    Returns
    ------------
    new_ref : a 3-dimentional array
        The drift corrected reference image.
    new_ch1 : a 3-dimentional array
        The drift corrected ch1 image.
    '''

    assert ref.shape == ch1.shape
    sr = StackReg(StackReg.TRANSLATION)
        
    new_ref = np.empty(ref.shape)
    new_ch1 = np.empty(ch1.shape)
    print ('Image alignment in progress...')
    if len(ref.shape) > 2: #if image has more than 1 slice
        tmats = sr.register_stack(ref, reference='mean')
        new_ref = sr.transform_stack(ref)
        new_ch1 = sr.transform_stack(ch1)

        return new_ref, new_ch1, tmats
    else:
  
        
        ###new code###
        new_ref = ref
        tmats = sr.register_stack(ref, reference='mean')
        new_ch1 = sr.transform_stack(ch1)
        
        ###new code###
        
        return new_ref, new_ch1, tmats
    
def apply_tmats(tmats, ch1):  
    '''
    Parameters
    ------------
    tmats : array of float64
        The transformation matrix generated by sr.register_stack() function
    ch1 : an array
        The image stack to be aligned.
    
    Returns
    ------------
    new_ch1 : array of float64
        The aligned image.
    
    '''

    sr = StackReg(StackReg.TRANSLATION)
    
    new_ch1 = np.empty(ch1.shape)

    new_ch1 = sr.transform_stack(ch1, tmats=tmats)

    return new_ch1

def remove_zero_padding(img):
    '''
    This is to make sure that the 0 padding from drift correction doesn't affect segmentation
    '''
    img[np.where(img == 0)] = np.mean(img)
    return img

def sub_pixel_registration(fix_frame, shifted_frame, upsample_factor = 20, manual_shift = None):
    '''
    This function takes a reference frame (fix_frame) and a shifted frame (shifted_frame)
    and align the shifted frame to the reference frame based on the phase_cross_correlation function.
    
    Parameters
    ------------
    fix_frame : a 2D array
        The reference frame which will be aligned to.
    shifted_frame : a 2D array
        The image to be aligned.
    upsample_factor : Images will be registered to within 1 / upsample_factor of a pixel. 
                      E.g., upsample_factor == 20 means the images will be registered within 1/20th of a pixel.  1 means no upsampling.
    manual_shift : a list
        The shifted_frame will be shifted based on this parameter. For example, [0, -1] means it will shift the image by 1 pixel. 
        Note: it will not run the registration algorithm if manual_shift is True. 
    
    Returns
    ------------
    The aligned array.
    
    '''
    
    assert fix_frame.shape == shifted_frame.shape # check if these frames have the same dimensions.
    
    if manual_shift:
        print('Manual shift was used...')
        xoff, yoff = manual_shift[1], manual_shift[0]

    else:
        shifted, error, diffphase = phase_cross_correlation(fix_frame, shifted_frame, upsample_factor=upsample_factor)
        xoff, yoff = -shifted[1], -shifted[0]
        
    corrected_img = ndi.shift(shifted_frame, shift=(xoff,yoff), mode='constant',  cval=np.median(shifted_frame))

    # the upsample factor will affect the precision
    # detected_shift, error, phasediff = phase_cross_correlation(fix_frame, shifted_frame, upsample_factor=upsample_factor)
    # print(f"Detected pixel offset (row, col): {-detected_shift}")
    return corrected_img, xoff, yoff

def sub_pixel_registration_stacks(stack_1, stack_2, upsample_factor = 10):
    '''
    This function takes a reference frame (fix_frame) and a shifted frame (shifted_frame)
    and align the shifted frame to the reference frame based on the phase_cross_correlation function.
    
    Parameters
    ------------
    stack_1 : a 3D array
        A reference stack that will be aligned.
    stack_2 : a 3D array
        Another stack that will be aligned based on the same alignment of stack_1.
    upsample_factor : Images will be registered to within 1 / upsample_factor of a pixel. 
                      E.g., upsample_factor == 20 means the images will be registered within 1/20th of a pixel.  1 means no upsampling.

    Returns
    ------------
    new_stack_1 : a 3D array
        The corrected stack_1.
    new_stack_2 : a 3D array
        The aligned stack_2.
    
    '''
    
    assert stack_1.shape == stack_2.shape # check if these frames have the same dimensions.
    
    # create placeholders for the corrected images
    new_stack_1 = np.empty(stack_1.shape, dtype=stack_1.dtype)
    new_stack_2 = np.empty(stack_2.shape, dtype=stack_2.dtype)
    
    # assign the original first frame to the placeholder
    new_stack_1[0,:,:] = stack_1[0,:,:]
    new_stack_2[0,:,:] = stack_2[0,:,:]
    
    for frame in range(stack_1.shape[0]-1):
        detected_shift, error, phasediff = phase_cross_correlation(new_stack_1[frame], stack_1[frame+1], upsample_factor=upsample_factor)
        print(f"Detected pixel offset (row, col): {-detected_shift}")
        new_stack_1[frame+1,:,:] = ndi.shift(stack_1[frame+1], detected_shift)
        new_stack_2[frame+1,:,:] = ndi.shift(stack_2[frame+1], detected_shift)
 
    return new_stack_1, new_stack_2
    

def optical_flow_registration(img, offset_img):
    
    '''
    This function performs an optical flow analysis.
    
    Parameters
    ------------
    img : an array 
        The reference image.
    offset_img : an array
        The image to be aligned.
    
    Returns
    ------------
    offset_img : an array
        The aligned image.
    xoff : the shift on the x axis
    yoff : the shift on the y axis
    
    '''
    
    flow = optical_flow_tvl1(img, offset_img)
    xoff = np.mean(flow[1,:,:])
    yoff = np.mean(flow[0,:,:])
    offset_img = ndi.shift(offset_img, shift=(xoff,yoff), mode='constant', cval=np.median(offset_img))
    # offset_img = exposure.rescale_intensity(aligned, in_range='image', out_range=(offset_img.min(), offset_img.max()))  
    
    return offset_img, xoff, yoff


def pystackreg_registration(img, offset_img, method = 1):
    
    assert img.shape == offset_img.shape
    
    if method == 1:
        sr = StackReg(StackReg.TRANSLATION)
    elif method == 2: 
        sr = StackReg(StackReg.RIGID_BODY)
    else: 
        return print('No methods was selected...')
    
    corrected_offset_img = sr.register_transform(img, offset_img)
    
    if img.dtype == 'uint16':
        corrected_offset_img = to_uint16(corrected_offset_img) # convert it back to 16-bit
    
    return corrected_offset_img

def top_hat_recon(img, SE = disk(5)):
    
    # dot_zoom_smooth = filters.gaussian(img[0], sigma=1, preserve_range=True)

    top_hat = white_tophat(img, footprint=SE)
    
    #top_hat_mask = top_hat > np.mean(top_hat)+np.std(top_hat)
      
    top_hat_float = img_as_float(top_hat.copy())
    seed = np.copy(top_hat_float)
    seed[1:-1, 1:-1] = top_hat_float.min()
    mask = top_hat_float
    recon = reconstruction(seed, mask, method='dilation')
    
    return (top_hat - recon).astype(img.dtype)
    
